"use strict";(self.webpackChunkfound_docs=self.webpackChunkfound_docs||[]).push([[746],{5768:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(2488),o=n(3808),i=n(2949),r=n(6412),s=n(7294);function d(e){let{children:t,startRoute:n,dependencies:d={}}=e;const l=(e=>s.Children.toArray(e).reduce(((e,t)=>{if("pre"!==t.props.mdxType)return e;const{props:n}=t.props.children;let a,o=!1,i=!1;if(n.metastring){const[e,...t]=n.metastring.split(" ");a=`/${e}`,t.includes("hidden")&&(o=!0),t.includes("active")&&(i=!0)}else if("language-js"===n.className)a="/App.js";else if("language-ts"===n.className)a="/App.tsx";else if("language-tsx"===n.className)a="/App.tsx";else{if("language-css"!==n.className)throw new Error(`Code block is missing a filename: ${n.children}`);a="/styles.css"}if(e[a])throw new Error(`File ${a} was defined multiple times. Each file snippet should have a unique path name`);return e[a]={code:n.children,hidden:o,active:i},e}),{}))(t),{colorMode:p}=(0,i.I)(),c=(0,r.p)();return s.createElement("div",{style:{"--prism-background-color":c.plain.backgroundColor,marginBottom:"2rem"}},s.createElement(a.xR,{template:"react-ts",files:l,theme:"dark"===p?o.cL:o.A1,options:{startRoute:n,showNavigator:!0,editorHeight:400,editorWidthPercentage:60,externalResources:["https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap-reboot.min.css"]},customSetup:{dependencies:{...d,found:"*"}}}))}},6342:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));n(5768);const i={sidebar_position:1},r="How it works",s={unversionedId:"getting-started/how-it-works",id:"getting-started/how-it-works",title:"How it works",description:"A reasonably deep-dive into how found does what it does.",source:"@site/docs/getting-started/how-it-works.mdx",sourceDirName:"getting-started",slug:"/getting-started/how-it-works",permalink:"/found/docs/getting-started/how-it-works",draft:!1,editUrl:"https://github.com/4Catalyzer/found/edit/master/www/docs/getting-started/how-it-works.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Quick start",permalink:"/found/docs/getting-started/quick-start"},next:{title:"Data fetching",permalink:"/found/docs/getting-started/data-fetching"}},d={},l=[{value:"An example",id:"an-example",level:2},{value:"Matching",id:"matching",level:2},{value:"Resolution",id:"resolution",level:2},{value:"Data fetching and code splitting",id:"data-fetching-and-code-splitting",level:3},{value:"Element construction",id:"element-construction",level:3},{value:"Loading states",id:"loading-states",level:2},{value:"Customizing",id:"customizing",level:2}],p={toc:l};function c(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-it-works"},"How it works"),(0,o.kt)("p",null,"A reasonably deep-dive into how found does what it does."),(0,o.kt)("h2",{id:"an-example"},"An example"),(0,o.kt)("p",null,'Consider the following wireframe of a web app with side navigation\nand detail area. The user can navigate to sections (such as "products") and\nsee a list of products. Clicking further on a product navigates to a nested\ndetail view with tab navigation for that specific product.'),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Product wireframe",src:n(5663).Z+"#gh-light-mode-only",width:"1154",height:"507"}),"\n",(0,o.kt)("img",{alt:"Product wireframe",src:n(5538).Z+"#gh-dark-mode-only",width:"1154",height:"507"})),(0,o.kt)("p",null,"With Found we can represent this UI with the following route tree and config:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'<Route path="/" Component={AppPage}>\n  <Route path="customers">\n    <Route Component={CustomersIndexPage} />\n    <Route path=":customerId" Component={CustomerPage} />\n  </Route>\n\n  <Route path="products">\n    <Route Component={ProductsIndexPage} getData={fetchProducts} />\n    <Route path="create" Component={ProductCreatePage} />\n\n    <Route\n      path=":productId"\n      Component={ProductPage}\n      getData={fetchProduct}\n    >\n      <Route\n        path="edit"\n        Component={ProductEditPage}\n        getData={fetchProductById}\n      />\n      <Route\n        path="history"\n        Component={ProductHistoryPage}\n        getData={fetchProductHistory}\n      />\n    </Route>\n  </Route>\n\n  <Route path="settings" Component={SettingsPage} />\n</Route>\n')),(0,o.kt)("p",null,"Which can also be illustrated via the following tree graph:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"route-tree",src:n(3005).Z+"#gh-light-mode-only",width:"913",height:"466"}),"\n",(0,o.kt)("img",{alt:"route-tree",src:n(9419).Z+"#gh-dark-mode-only",width:"913",height:"466"})),(0,o.kt)("p",null,"Let's consider a single URL and break down how found determines what UI to show and when.\nIf we want to navigate to a Product's history page we would use the\nfollowing URL: ",(0,o.kt)("inlineCode",{parentName:"p"},"/products/1/history"),". Clicking on a ",(0,o.kt)("inlineCode",{parentName:"p"},"<Link>"),", calling\n",(0,o.kt)("inlineCode",{parentName:"p"},"router.push('/products/1/history')"),', or updating the browser URL bar triggers a new "match" resolution.'),(0,o.kt)("h2",{id:"matching"},"Matching"),(0,o.kt)("p",null,"The first step in routing is to produce a ",(0,o.kt)("inlineCode",{parentName:"p"},"match"),". A match is created by a class called the ",(0,o.kt)("inlineCode",{parentName:"p"},"Matcher"),",\nwhich is generally an implementation detail of Found. Simply put, the Matcher takes a URL and produces a\nset of route objects that coorespond to that URL."),(0,o.kt)("p",null,'This is accomplished by decomposing the URL into path segments and "matching" them with nodes in our route tree.\nIllustrated here is a match to our Product history page.'),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"route-match",src:n(9673).Z+"#gh-light-mode-only",width:"913",height:"510"}),"\n",(0,o.kt)("img",{alt:"route-match",src:n(1838).Z+"#gh-dark-mode-only",width:"913",height:"510"})),(0,o.kt)("p",null,"If the matcher is able to map the entire URL to a set of Routes, the matching succeeds and a\nmatch object is produced (simplified a bit here):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"Match {\n  location: {\n    pathname: '/products/1/history',\n    query: {},\n    state: null,\n  },\n  params: { projectId: '1' },\n  routes: [\n    { path: '/', Component: AppPage, },\n    { path: 'products' },\n    { path: ':projectId', Component: ProductPage, getData: fetchProductById },\n    { path: 'histrory', Component: ProductHistoryPage, getData: fetchProductHistory },\n  ]\n}\n\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},'matching can only complete at "leaf" nodes in the route tree. This means that\nroutes that could be leaf or branch nodes (such as ',(0,o.kt)("inlineCode",{parentName:"p"},"/products"),') need to include an\n"index" route in order to match sucessfully. An index route is a route with a ',(0,o.kt)("inlineCode",{parentName:"p"},"Component"),"\nand no ",(0,o.kt)("inlineCode",{parentName:"p"},"path"),", as seen above in the route config.")),(0,o.kt)("h2",{id:"resolution"},"Resolution"),(0,o.kt)("p",null,'The next part in the process is "resolving". The router ',(0,o.kt)("inlineCode",{parentName:"p"},"Resolver")," is responsible for mapping the\nmatched routes to a set of React ",(0,o.kt)("inlineCode",{parentName:"p"},"element"),"s in order to render the UI for the URL.\nTo accomplish this it may need to fetch components or server data asynchronously, as specified by the route."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"resolver",src:n(7341).Z+"#gh-light-mode-only",width:"980",height:"362"}),"\n",(0,o.kt)("img",{alt:"resolver",src:n(2660).Z+"#gh-dark-mode-only",width:"980",height:"362"})),(0,o.kt)("h3",{id:"data-fetching-and-code-splitting"},"Data fetching and code splitting"),(0,o.kt)("p",null,"Each route in the matched set may specify a ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," property to fetch data necessary to\nrender its ",(0,o.kt)("inlineCode",{parentName:"p"},"Component"),". The Resolver calls each and collects the returned ",(0,o.kt)("inlineCode",{parentName:"p"},"Promise"),"s which are\nall allowed to resolve in parallel. unless a route is ",(0,o.kt)("inlineCode",{parentName:"p"},"defer"),"ed in which case the promises are split into batches\nbased on the route hierarchy."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const routeData = await Promise.all(\n  matchedRoutes.map((route: Route) => {\n    return route.getData ? route.getData(match) : undefined;\n  });\n)\n")),(0,o.kt)("p",null,"Similarly Route components can be asynchronously loaded by specifing ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent")," instead\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"Component"),". Components are also loaded in parallel and awaited before resolving to a set of elements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const routeComponents = await Promise.all(\n  matchedRoutes.map((route: Route) => {\n    return route.getComponent ? route.getComponent(match) : route.Component;\n  });\n)\n")),(0,o.kt)("h3",{id:"element-construction"},"Element construction"),(0,o.kt)("p",null,"After data and components are resolved, each route is constructed into an element that will be rendered\nby the Router. Consider how our matched routes relate to the proposed UI:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"route-ui-map",src:n(4411).Z+"#gh-light-mode-only",width:"563",height:"531"}),"\n",(0,o.kt)("img",{alt:"route-ui-map",src:n(249).Z+"#gh-dark-mode-only",width:"563",height:"531"})),(0,o.kt)("p",null,"Each route is ordered by its depth in the route tree and is responsible for\nrendering itself as well as any nested routes it may contain. Before we\ncan compose the UI together we need to construct its individual pieces.\nThis is done by combining our fetched components and data into elements:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const routeComponents = [\n  AppPage,\n  null,\n  ProductPage,\n  ProductHistoryPage,\n];\nconst routeData = [null, null, {}, {}];\n\nroutes.map((route, index) => {\n  const Component = routeComponents[index];\n  const data = routeData[index];\n\n  return Component ? <Component data={data} /> : null;\n});\n")),(0,o.kt)("p",null,"Finally this array is folded together by the Router into:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<AppPage>\n  <ProductPage>\n    <ProductHistoryPage />\n  </ProductPage>\n</AppPage>\n")),(0,o.kt)("h2",{id:"loading-states"},"Loading states"),(0,o.kt)("p",null,"One point that was glossed over is how routes can control their own loading UI\nwhile data and components are being fetched. To handle these states the ",(0,o.kt)("inlineCode",{parentName:"p"},"Resolver")," actually produces multiple\narrays of elements. While waiting for components and data to be fetched it calls each ",(0,o.kt)("inlineCode",{parentName:"p"},"route.render"),",\nwith the intermediary state. Once the async values are resolved each ",(0,o.kt)("inlineCode",{parentName:"p"},"route.render")," is called again\nwith the final values."),(0,o.kt)("p",null,"This gives the route total control over how it handles loading fallbacks for itself and child routes. A Route\ncan explicitly render nothing (",(0,o.kt)("inlineCode",{parentName:"p"},"null"),"), a loading spinner, a skeleton UI, or whatever else it wants while\nit waits for data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},'routes = [\n  // ...\n  {\n    path: ":productId",\n    getComponent: () =>\n      import("./components/ProductPage").then((m) => m.default),\n    getData: fetchProductById,\n    render({ props, Component }) {\n      // if Component is not present it is still being fetched\n      if (!Component) {\n        return <Spinner />;\n      }\n\n      // props is the return value of `getData` if\n      // it\'s not present data is still loading\n      if (!props) {\n        <Component showSkeleton />;\n      }\n\n      // Otherwise render the component with it\'s props\n      return <Component {...props} />;\n    },\n  },\n];\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("inlineCode",{parentName:"p"},"null")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," mean different things as a return value of ",(0,o.kt)("inlineCode",{parentName:"p"},"router.render"),"!\nIf you return ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," the router will render ",(0,o.kt)("em",{parentName:"p"},"nothing")," for that element, whereas ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),'\nit treated as a special value that means "I can\'t render yet", which tells the router to continue\nto show the existing UI until the route is ready.')),(0,o.kt)("p",null,"This flexibility allows for easy implementation of many different loading UI patterns!"),(0,o.kt)("h2",{id:"customizing"},"Customizing"),(0,o.kt)("p",null,"Nearly all of the behavior covered here is customizable and extensible. Making found ideal\nfor all sorts of of React applications. Checkout our ",(0,o.kt)("a",{parentName:"p",href:"/found/docs/advanced/further-reading"},"examples and extensions")," for more ideas:"))}c.isMDXComponent=!0},2660:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/resolver-d-71c630fa42737caa299f7dcc64788636.png"},7341:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/resolver-l-bd9447c82f1da3430fcc71ffc9efea2a.png"},9419:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/route-graph-d-3f167ad375c7343107d8b8561637e556.png"},3005:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/route-graph-l-9e64d4bfec32926e42206a0d5a06ca11.png"},1838:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/route-match-d-0d19eb7e628b3495bf2cba46e0f83b00.png"},9673:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/route-match-l-ac500a2e4541c07d2045b856346069f9.png"},249:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/route-ui-map-d-0371d47fc2bde6d591913daf8c4cc202.png"},4411:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/route-ui-map-l-b08a6e4f684b10333935349a1a7699e2.png"},5538:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/wireframe-d-b4cc0e5c37767f15bd236573e6828cd5.png"},5663:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/wireframe-l-d381e41711538dc8e91eae25b1cf74dc.png"}}]);