"use strict";(self.webpackChunkfound_docs=self.webpackChunkfound_docs||[]).push([[860],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),c=d(n),m=o,h=c["".concat(p,".").concat(m)]||c[m]||u[m]||r;return n?a.createElement(h,i(i({ref:t},s),{},{components:n})):a.createElement(h,i({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3828:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:1},i="Route configuration",l={unversionedId:"configuration/route-config",id:"configuration/route-config",title:"Route configuration",description:"A route object under the default matching algorithm and route element resolver consists of the following properties, all of which are optional:",source:"@site/docs/configuration/route-config.md",sourceDirName:"configuration",slug:"/configuration/route-config",permalink:"/found/docs/configuration/route-config",draft:!1,editUrl:"https://github.com/4Catalyzer/found/edit/master/www/docs/configuration/route-config.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Configuration",permalink:"/found/docs/category/configuration"},next:{title:"Router configuration",permalink:"/found/docs/configuration/router-config"}},p={},d=[{value:"<code>path</code>",id:"path",level:4},{value:"<code>Component</code> or <code>getComponent</code>",id:"component-or-getcomponent",level:4},{value:"<code>data</code> or <code>getData</code>",id:"data-or-getdata",level:4},{value:"<code>defer</code>",id:"defer",level:4},{value:"<code>render</code>",id:"render",level:4}],s={toc:d};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"route-configuration"},"Route configuration"),(0,o.kt)("p",null,"A route object under the default matching algorithm and route element resolver consists of the following properties, all of which are optional:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"path: string"),": a string defining the pattern for the route")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"Component")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent")," - the component for the route, or a method that returns the component for the route"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"  Component: React.ComponentType<any>;\n  getComponent: (match: RouteMatch) => React.ComponentType<any> | Promise<React.ComponentType<any>>;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"data")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"getData"),": additional data for the route, or a method that returns additional data for the route")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"data: any;\ngetData: (match: RouteMatch) => any;\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"defer: boolean"),": whether to wait for all parent ",(0,o.kt)("inlineCode",{parentName:"li"},"data")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"getData")," promises to resolve before getting data for this route and its descendants"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"render: (args: RouteRenderArgs): ResolvedElement | undefined"),": a method that returns the element for the route"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"children"),": an array of child route objects, or an object of those arrays; if using JSX configuration components, this comes from the JSX children")),(0,o.kt)("p",null,"A route configuration consists of an array of route objects."),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"You can generate such an array of route objects from JSX with ",(0,o.kt)("inlineCode",{parentName:"p"},"<Route>")," elements using ",(0,o.kt)("inlineCode",{parentName:"p"},"makeRouteConfig"),", as shown previously in ",(0,o.kt)("a",{parentName:"p",href:"/found/docs/getting-started/quick-start"},"quick start"),".")),(0,o.kt)("p",null,"By default, ",(0,o.kt)("inlineCode",{parentName:"p"},"<Route />")," components receive the following additional props describing the current routing state:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"match: Match"),": an object with router state properties, conforming to the ",(0,o.kt)("inlineCode",{parentName:"li"},"matchShape")," prop type validator")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="/types/index.d.ts"',title:'"/types/index.d.ts"'},"interface Match<TContext = any> {\n  location: LocationDescriptor; // The current [`location object`](https://github.com/4Catalyzer/farce#locations-and-location-descriptors)\n  params: Params; // The union of path parameters for all matched routes\n  routes: RouteObject[]; // An array of all matched route objects\n  route: RouteObject; // The route object corresponding to this component\n  routeParams: Params[]; // The path parameters for `route`\n  routeIndices: RouteIndices;\n  context: TContext;\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"router: Router"),": an object with static router properties, conforming to the ",(0,o.kt)("inlineCode",{parentName:"li"},"routerShape")," prop type validator")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="/types/index.d.ts"',title:'"/types/index.d.ts"'},"interface Router {\n  push: (location: LocationDescriptor) => void; // Navigates to a new location\n  replace: (location: LocationDescriptor) => void; // Replaces the existing history entry\n  go: (delta: number) => void; // Moves `delta` steps in the history stack\n  isActive: (\n    match: Match,\n    location: LocationDescriptor,\n    { exact: boolean }\n  ) => boolean; // For `match` as above, returns whether `match` corresponds to `location` or a subpath of `location`; if `exact` is set, returns whether `match` corresponds exactly to `location`\n  format: (pattern: string, params: ParamsDescriptor) => string;\n  addNavigationListener(\n    listener: (location: LocationDescriptor) => any,\n    { beforeUnload: boolean }\n  ); // Adds a [navigation listener](https://github.com/4Catalyzer/farce#navigation-listeners) that can [block navigation](#blocking-navigation)\n}\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent")," method receives an object containing the same properties as the ",(0,o.kt)("inlineCode",{parentName:"p"},"match")," object above, with an additional ",(0,o.kt)("inlineCode",{parentName:"p"},"router")," property as above.")),(0,o.kt)("h4",{id:"path"},(0,o.kt)("inlineCode",{parentName:"h4"},"path")),(0,o.kt)("p",null,"Specify a ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," pattern to control the paths for which a route is active. These patterns are handled using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/pillarjs/path-to-regexp"},"Path-to-RegExp")," and follow the rules there. Both named and unnamed parameters will be captured in ",(0,o.kt)("inlineCode",{parentName:"p"},"params")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"routeParams")," as below. The following are common patterns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/path/subpath"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/path/subpath")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/path/:param"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/path/foo")," with ",(0,o.kt)("inlineCode",{parentName:"li"},"params")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"{ param: 'foo' }")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/path/:regexParam(\\\\d+)"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/path/123")," with ",(0,o.kt)("inlineCode",{parentName:"li"},"params")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"{ regexParam: '123' }")),(0,o.kt)("li",{parentName:"ul"},"Does not match ",(0,o.kt)("inlineCode",{parentName:"li"},"/path/foo")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/path/:optionalParam?"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/path/foo")," with ",(0,o.kt)("inlineCode",{parentName:"li"},"params")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"{ optionalParam: 'foo' }")),(0,o.kt)("li",{parentName:"ul"},"Matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/path")," with ",(0,o.kt)("inlineCode",{parentName:"li"},"params")," of ",(0,o.kt)("inlineCode",{parentName:"li"},"{ optionalParam: undefined }")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"/path/*"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Matches ",(0,o.kt)("inlineCode",{parentName:"li"},"/path/foo/bar"))))),(0,o.kt)("p",null,"Routes are matched based on their ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," properties in a depth-first manner, where ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," on the route must match the prefix of the remaining current path. Routing continues through any routes that do not have ",(0,o.kt)("inlineCode",{parentName:"p"},"path"),' set. To configure a default or "index" route, use a route with no ',(0,o.kt)("inlineCode",{parentName:"p"},"path"),"."),(0,o.kt)("h4",{id:"component-or-getcomponent"},(0,o.kt)("inlineCode",{parentName:"h4"},"Component")," or ",(0,o.kt)("inlineCode",{parentName:"h4"},"getComponent")),(0,o.kt)("p",null,"Define the component for a route using either a ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," field or a ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent")," method. ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," should be a component class or function. ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent")," should be a function that returns a component class or function, or a promise that resolves to either of those. Routes that specify neither will still match if applicable, but will not have a component associated with them."),(0,o.kt)("h4",{id:"data-or-getdata"},(0,o.kt)("inlineCode",{parentName:"h4"},"data")," or ",(0,o.kt)("inlineCode",{parentName:"h4"},"getData")),(0,o.kt)("p",null,"Specify the ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," property or ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," method to inject data into a route component as the ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," prop. ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," can be any value. ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," can be any value, or a promise that resolves to any value. ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," receives an object containing the routing state, as described above for ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," method is intended for loading additional data from your back end for a given route. By design, all requests for asynchronous component and data dependencies will be issued in parallel. Found uses static route configurations specifically to enable issuing these requests in parallel."),(0,o.kt)("p",null,"If you need additional context such as a store instance to fetch data, specify this as the ",(0,o.kt)("inlineCode",{parentName:"p"},"matchContext")," prop to your router. This context value will then be available as the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," property on the argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"getData"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const route = {\n  path: "widgets/:widgetId",\n  Component: WidgetPage,\n  getData: ({ params, context }) =>\n    context.store.dispatch(Actions.getWidget(params.widgetId)),\n};\n\n// <Router matchContext={{ store }} />\n')),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"It does not make sense to specify ",(0,o.kt)("inlineCode",{parentName:"p"},"data")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," if the route does not have a component as above or a ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," method.")),(0,o.kt)("h4",{id:"defer"},(0,o.kt)("inlineCode",{parentName:"h4"},"defer")),(0,o.kt)("p",null,"By default, Found will issue all data fetching operations in parallel. However, if you wish to defer data fetching for a given route until its parent data promises has been resolved, you may do so by setting ",(0,o.kt)("inlineCode",{parentName:"p"},"defer")," on the route."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"<Route Component={Parent} getData={getParentData}>\n  <Route Component={Child} getData={getChildData} defer />\n</Route>\n")),(0,o.kt)("p",null,"Setting ",(0,o.kt)("inlineCode",{parentName:"p"},"defer")," on a route will make the resolver defer calling its ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," method and the ",(0,o.kt)("inlineCode",{parentName:"p"},"getData")," methods on all of its descendants until all of its parent data promises have resolved."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"This should be a relatively rare scenario, as generally user experience is better if all data are fetched in parallel, but in some cases it can be desirable to avoid making data fetching operations that are guaranteed to fail, such as when the user is not authenticated, when optimizing for client bandwidth usage or API utilization.")),(0,o.kt)("h4",{id:"render"},(0,o.kt)("inlineCode",{parentName:"h4"},"render")),(0,o.kt)("p",null,"Specify the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," method to further customize how the route renders. It receives an object with the following properties:"),(0,o.kt)("p",null,"It should return:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"another function that receives its children as an argument and returns a React element; this function receives",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"a React element when not using named child routes"),(0,o.kt)("li",{parentName:"ul"},"an object when using named child routes"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"null")," when it has no children"))),(0,o.kt)("li",{parentName:"ul"},"a React element to render that element"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"undefined")," if it has a pending asynchronous component or data dependency and is not ready to render"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"null")," to render its children (or nothing if there are no children)")),(0,o.kt)("p",null,"Note that, when specifying this ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," method, ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"getComponent")," will have no effect other than controlling the value of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," property on the argument to ",(0,o.kt)("inlineCode",{parentName:"p"},"render"),". Additionally, the behavior is different between returning a function that returns ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," and returning ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," directly; in the former case, nothing will be rendered, while in the latter case, the route's children will be rendered."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="/types/index.d.ts"',title:'"/types/index.d.ts"'},"interface RenderProps {\n  match: Match; // The routing state object, as above\n  Component: React.ComponentType<any>; // The component for the route, if any; `null` if the component has not yet been loaded\n  props: Match & {data: any | null}; // `The default props for the route component, specifically `match` with `data` as an additional property; `null` if `data` have not yet been loaded\n  data: any; // The data for the route, as above; `null` if the data have not yet been loaded\n}\n\nrender: (e: RenderProps) => React.ComponentType<any> | (children) => React.ComponentType<any> | null | undefined;\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"You can use this method to render per-route loading state."),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"function loadingRender({ Component, props }) {\n  if (!Component || !props) {\n    return <LoadingIndicator />;\n  }\n\n  return <Component {...props} />;\n}\n\n<Route render={loadingRender} {...rest} />;\n"))),(0,o.kt)("p",null,"If any matched routes have unresolved asynchronous component or data dependencies, the router will initially attempt to render all such routes in their loading state. If those routes all implement ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," methods and return non-",(0,o.kt)("inlineCode",{parentName:"p"},"undefined")," values from their ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," methods, the router will render the matched routes in their loading states. Otherwise, the router will continue to render the previous set of routes until all asynchronous dependencies resolve."))}u.isMDXComponent=!0}}]);