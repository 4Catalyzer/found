"use strict";(self.webpackChunkfound_docs=self.webpackChunkfound_docs||[]).push([[335],{8453:(e,r,o)=>{o.d(r,{R:()=>i,x:()=>a});var n=o(6540);const t={},s=n.createContext(t);function i(e){const r=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(s.Provider,{value:r},e.children)}},9833:(e,r,o)=>{o.r(r),o.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"configuration/router-config","title":"Router configuration","description":"Found exposes a number of router component class factories at varying levels of abstraction. These factories accept the static configuration properties for the router, such as the route configuration. The use of static configuration allows for efficient, parallel data fetching and state management as above.","source":"@site/docs/configuration/router-config.md","sourceDirName":"configuration","slug":"/configuration/router-config","permalink":"/found/docs/configuration/router-config","draft":false,"unlisted":false,"editUrl":"https://github.com/4Catalyzer/found/edit/master/www/docs/configuration/router-config.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Route configuration","permalink":"/found/docs/configuration/route-config"},"next":{"title":"Navigation","permalink":"/found/docs/configuration/navigation"}}');var t=o(4848),s=o(8453);const i={sidebar_position:2},a="Router configuration",c={},d=[{value:"<code>createBrowserRouter</code>",id:"createbrowserrouter",level:4},{value:"<code>createFarceRouter</code>",id:"createfarcerouter",level:4}];function l(e){const r={a:"a",code:"code",h1:"h1",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"router-configuration",children:"Router configuration"})}),"\n",(0,t.jsx)(r.p,{children:"Found exposes a number of router component class factories at varying levels of abstraction. These factories accept the static configuration properties for the router, such as the route configuration. The use of static configuration allows for efficient, parallel data fetching and state management as above."}),"\n",(0,t.jsx)(r.h4,{id:"createbrowserrouter",children:(0,t.jsx)(r.code,{children:"createBrowserRouter"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"createBrowserRouter"})," creates a basic router component class that uses the HTML5 History API for navigation. This factory uses reasonable defaults that should fit a variety use cases."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'import { createBrowserRouter } from "found";\n\nconst BrowserRouter = createBrowserRouter({\n  routeConfig,\n\n  renderError: ({ error }) => (\n    <div>{error.status === 404 ? "Not found" : "Error"}</div>\n  ),\n});\n\nReactDOM.render(<BrowserRouter />, document.getElementById("root"));\n'})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"createBrowserRouter"})," takes an options object. The only mandatory property on this object is ",(0,t.jsx)(r.code,{children:"routeConfig"}),", which should be a route configuration as above."]}),"\n",(0,t.jsx)(r.p,{children:"The options object also accepts a number of optional properties:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"historyMiddlewares: Middleware[]"})," - an array of ",(0,t.jsx)(r.a,{href:"https://github.com/4Catalyzer/farce#middlewares",children:"Farce history middlewares"}),"; by default, an array containing only ",(0,t.jsx)(r.code,{children:"queryMiddleware"})]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"historyOptions: Omit<HistoryEnhancerOptions, 'protocol' | 'middlewares'>;"})," - additional configuration options for the Farce history store enhancer"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"renderPending: (args: RenderPendingArgs) => React.ReactElement;"}),": a custom render function called when some routes are not yet ready to render, due to those routes have unresolved asynchronous dependencies and no route-level ",(0,t.jsx)(r.code,{children:"render"})," method for handling the loading state"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"renderReady: (args: RenderPendingArgs) => React.ReactElement;"}),": a custom render function called when all routes are ready to render"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"renderError: (args: RenderPendingArgs) => React.ReactElement;"}),": a custom render function called if an ",(0,t.jsx)(r.code,{children:"HttpError"})," is thrown while resolving route elements"]}),"\n"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-ts",metastring:'title="/types/index.d.ts"',children:"type RenderPendingArgs = Match;\ninterface Match<TContext = any> {\n  location: LocationDescriptor; // The current [location object](https://github.com/4Catalyzer/farce#locations-and-location-descriptors)\n  params: Params; // The union of path parameters for all matched routes\n  routes: RouteObject[]; // An array of all matched route objects\n  route: RouteObject; // The route object corresponding to this component\n  routeParams: Params[]; // The path parameters for `route`\n  routeIndices: RouteIndices;\n  context: TContext;\n}\n"})}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"render: (args: RenderArgs) => React.ReactElement;"}),": a custom render function called in all cases, superseding ",(0,t.jsx)(r.code,{children:"renderPending"}),", ",(0,t.jsx)(r.code,{children:"renderReady"}),", and ",(0,t.jsx)(r.code,{children:"renderError"}),"; by default, this is ",(0,t.jsx)(r.code,{children:"createRender({ renderPending, renderReady, renderError }: CreateRenderOptions)"})]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["The ",(0,t.jsx)(r.code,{children:"renderPending"}),", ",(0,t.jsx)(r.code,{children:"renderReady"}),", ",(0,t.jsx)(r.code,{children:"renderError"}),", and ",(0,t.jsx)(r.code,{children:"render"})," functions receive the routing state object as an argument, with the following additional properties:"]}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"elements: RenderArgsElements;"}),": if present, an array the resolved elements for the matched routes; the array item will be ",(0,t.jsx)(r.code,{children:"null"})," for routes without elements"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"error: HttpError"}),": if present, the ",(0,t.jsx)(r.code,{children:"HttpError"})," object thrown during element resolution with properties describing the error","\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"status: number"}),": the status code; this is the first argument to the ",(0,t.jsx)(r.code,{children:"HttpError"})," constructor"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:"data: any"}),": additional error data; this is the second argument to the ",(0,t.jsx)(r.code,{children:"HttpError"})," constructor"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.p,{children:["You should specify a ",(0,t.jsx)(r.code,{children:"renderError"})," function or otherwise handle error states. You can specify ",(0,t.jsx)(r.code,{children:"renderPending"})," and ",(0,t.jsx)(r.code,{children:"renderReady"})," functions to indicate loading state globally; the ",(0,t.jsx)(r.a,{href:"https://github.com/4Catalyzer/found/tree/master/examples/global-pending",children:"global pending state example"})," demonstrates doing this using a static container."]}),"\n",(0,t.jsxs)(r.p,{children:["The created ",(0,t.jsx)(r.code,{children:"<BrowserRouter>"})," accepts an optional ",(0,t.jsx)(r.code,{children:"matchContext: any"})," prop as described above that injects additional context into the route resolution methods."]}),"\n",(0,t.jsx)(r.h4,{id:"createfarcerouter",children:(0,t.jsx)(r.code,{children:"createFarceRouter"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"createFarceRouter"})," exposes additional configuration for customizing navigation management and route element resolution. To enable minimizing bundle size, it omits some defaults from ",(0,t.jsx)(r.code,{children:"createBrowserRouter"}),"."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-js",children:'import { BrowserProtocol, queryMiddleware } from "farce";\nimport { createFarceRouter, resolver } from "found";\n\nconst FarceRouter = createFarceRouter({\n  historyProtocol: new BrowserProtocol(),\n  historyMiddlewares: [queryMiddleware],\n  routeConfig,\n\n  renderError: ({ error }) => (\n    <div>{error.status === 404 ? "Not found" : "Error"}</div>\n  ),\n});\n\nReactDOM.render(\n  <FarceRouter resolver={resolver} />,\n  document.getElementById("root"),\n);\n'})}),"\n",(0,t.jsxs)(r.p,{children:["The options object for ",(0,t.jsx)(r.code,{children:"createFarceRouter"})," should have a ",(0,t.jsx)(r.code,{children:"historyProtocol"})," property that has a history protocol object. For example, to use the HTML History API as with ",(0,t.jsx)(r.code,{children:"createBrowserRouter"}),", you would provide ",(0,t.jsx)(r.code,{children:"new BrowserProtocol()"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:["The created ",(0,t.jsx)(r.code,{children:"<FarceRouter>"})," manages setting up and providing a Redux store with the appropriate configuration internally. It also requires a ",(0,t.jsx)(r.code,{children:"resolver"})," prop with the route element resolver object. For routes configured as above, this should be the ",(0,t.jsx)(r.code,{children:"resolver"})," object in this library."]})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);