"use strict";(self.webpackChunkfound_docs=self.webpackChunkfound_docs||[]).push([[4169],{8453:(e,r,n)=>{n.d(r,{R:()=>d,x:()=>i});var t=n(6540);const s={},o=t.createContext(s);function d(e){const r=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(o.Provider,{value:r},e.children)}},9564:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"advanced/server-side-rendering","title":"Server-side rendering","description":"Found supports server-side rendering for universal applications. Functionality specific to server-side rendering is available in found/server.","source":"@site/docs/advanced/server-side-rendering.md","sourceDirName":"advanced","slug":"/advanced/server-side-rendering","permalink":"/found/docs/advanced/server-side-rendering","draft":false,"unlisted":false,"editUrl":"https://github.com/4Catalyzer/found/edit/master/www/docs/advanced/server-side-rendering.md","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Minimizing bundle size","permalink":"/found/docs/advanced/minimize-bundle"},"next":{"title":"Hot reloading","permalink":"/found/docs/advanced/hot-reloading"}}');var s=n(4848),o=n(8453);const d={sidebar_position:8},i="Server-side rendering",c={},a=[{value:"Server-side rendering with custom Redux store",id:"server-side-rendering-with-custom-redux-store",level:4}];function l(e){const r={code:"code",h1:"h1",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"server-side-rendering",children:"Server-side rendering"})}),"\n",(0,s.jsxs)(r.p,{children:["Found supports server-side rendering for universal applications. Functionality specific to server-side rendering is available in ",(0,s.jsx)(r.code,{children:"found/server"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:["To render your application on the server, use ",(0,s.jsx)(r.code,{children:"getFarceResult"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'import { getFarceResult } from "found/server";\n\n/* ... */\n\napp.use(async (req, res) => {\n  const { redirect, status, element } = await getFarceResult({\n    url: req.url,\n    routeConfig,\n    render,\n  });\n\n  if (redirect) {\n    res.redirect(redirect.status, redirect.url);\n    return;\n  }\n\n  res.status(status).send(`\n<!DOCTYPE html>\n<html>\n\n<head>\n  <meta charset="UTF-8">\n  <title>Found Universal Example</title>\n</head>\n\n<body>\n<div id="root">${ReactDOMServer.renderToString(element)}</div>\n\n<script src="/static/bundle.js"><\/script>\n</body>\n\n</html>\n  `);\n});\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"getFarceResult"})," takes an options object. This object must include the ",(0,s.jsx)(r.code,{children:"url"})," property that is the full path of the current request, along with the ",(0,s.jsx)(r.code,{children:"routeConfig"})," and ",(0,s.jsx)(r.code,{children:"render"})," properties needed to create a Farce router component class normally."]}),"\n",(0,s.jsxs)(r.p,{children:["The options object for ",(0,s.jsx)(r.code,{children:"getFarceResult"})," also takes the ",(0,s.jsx)(r.code,{children:"historyMiddlewares"})," and ",(0,s.jsx)(r.code,{children:"historyOptions"})," properties, as above for creating Farce router component classes. This options object also takes optional ",(0,s.jsx)(r.code,{children:"matchContext"})," and ",(0,s.jsx)(r.code,{children:"resolver"})," properties, as described above as props for router components. ",(0,s.jsx)(r.code,{children:"resolver"})," defaults to the standard ",(0,s.jsx)(r.code,{children:"resolver"})," object in this library."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"getFarceResult"})," returns a promise for an object with the following properties:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"redirect"}),": if present, indicates that element resolution triggered a redirect; ",(0,s.jsx)(r.code,{children:"redirect.url"})," contains the full path for the redirect location"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"status"}),": if there was no redirect, the HTTP status code for the response; this will be ",(0,s.jsx)(r.code,{children:"error.status"})," from any encountered ",(0,s.jsx)(r.code,{children:"HttpError"}),", or 200 otherwise"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"element"}),": if there was no redirect, the React element corresponding to the router component on the client"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["This promise resolves when all asynchronous dependencies are available. If your routes require asynchronous data, e.g. from ",(0,s.jsx)(r.code,{children:"getData"})," methods, you may want to dehydrate those data on the server, then rehydrate them on the client, to avoid the client having to request those data again."]}),"\n",(0,s.jsxs)(r.p,{children:["When using server-side rendering, you need to delay the initial render on the client, such that the initial client-rendered markup matches the server-rendered markup. To do so, use ",(0,s.jsx)(r.code,{children:"createInitialBrowserRouter"})," or ",(0,s.jsx)(r.code,{children:"createInitialFarceRouter"})," instead of ",(0,s.jsx)(r.code,{children:"createBrowserRouter"})," or ",(0,s.jsx)(r.code,{children:"createFarceRouter"})," respectively."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'import { createInitialBrowserRouter } from "found";\n\n/* ... */\n\n(async () => {\n  const BrowserRouter = await createInitialBrowserRouter({\n    routeConfig,\n    render,\n  });\n\n  ReactDOM.render(<BrowserRouter />, document.getElementById("root"));\n})();\n'})}),"\n",(0,s.jsxs)(r.p,{children:["These behave similarly to their counterparts above, except that the options object for ",(0,s.jsx)(r.code,{children:"createInitialBrowserRouter"})," requires a ",(0,s.jsx)(r.code,{children:"render"})," method, and ignores the ",(0,s.jsx)(r.code,{children:"renderPending"}),", ",(0,s.jsx)(r.code,{children:"renderReady"}),", and ",(0,s.jsx)(r.code,{children:"renderError"})," properties. Additionally, these functions take the initial ",(0,s.jsx)(r.code,{children:"matchContext"})," and ",(0,s.jsx)(r.code,{children:"resolver"})," if relevant as properties on the options object, rather than as props."]}),"\n",(0,s.jsx)(r.h4,{id:"server-side-rendering-with-custom-redux-store",children:"Server-side rendering with custom Redux store"}),"\n",(0,s.jsxs)(r.p,{children:["Found exposes lower-level functionality for doing server-side rendering for use with your own Redux store. On the server, use ",(0,s.jsx)(r.code,{children:"getStoreRenderArgs"})," to get a promise for the arguments to your ",(0,s.jsx)(r.code,{children:"render"})," function, then wrap the rendered elements with a ",(0,s.jsx)(r.code,{children:"<RouterProvider>"}),"."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'import { getStoreRenderArgs } from "found";\nimport { RouterProvider } from "found/server";\n\n/* ... */\n\napp.use(async (req, res) => {\n  /* ... */\n\n  let renderArgs;\n\n  try {\n    renderArgs = await getStoreRenderArgs({\n      store,\n      matchContext,\n      resolver,\n    });\n  } catch (e) {\n    if (e.isFoundRedirectException) {\n      res.redirect(e.status, store.farce.createHref(e.location));\n      return;\n    }\n\n    throw e;\n  }\n\n  res.status(renderArgs.error ? renderArgs.error.status : 200).send(\n    renderPageToString(\n      <Provider store={store}>\n        <RouterProvider renderArgs={renderArgs}>\n          {render(renderArgs)}\n        </RouterProvider>\n      </Provider>,\n      store.getState(),\n    ),\n  );\n});\n'})}),"\n",(0,s.jsxs)(r.p,{children:["You must dispatch ",(0,s.jsx)(r.code,{children:"FarceActions.init()"})," before calling ",(0,s.jsx)(r.code,{children:"getStoreRenderArgs"}),". ",(0,s.jsx)(r.code,{children:"getStoreRenderArgs"})," takes an options object. This object must have the ",(0,s.jsx)(r.code,{children:"store"})," property for your store and the ",(0,s.jsx)(r.code,{children:"resolver"})," property as described above. It supports an optional ",(0,s.jsx)(r.code,{children:"matchContext"})," property as described above as well. ",(0,s.jsx)(r.code,{children:"getStoreRenderArgs"})," returns a promise that resolves to a ",(0,s.jsx)(r.code,{children:"renderArgs"})," object that can be passed into a ",(0,s.jsx)(r.code,{children:"render"})," function as above."]}),"\n",(0,s.jsxs)(r.p,{children:["On the client, pass the value resolved by by ",(0,s.jsx)(r.code,{children:"getStoreRenderArgs"})," to your ",(0,s.jsx)(r.code,{children:"<ConnectedRouter>"})," as the ",(0,s.jsx)(r.code,{children:"initialRenderArgs"})," prop."]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",children:'import { getStoreRenderArgs } from "found";\n\n/* ... */\n\n(async () => {\n  const initialRenderArgs = await getStoreRenderArgs({\n    store,\n    matchContext,\n    resolver,\n  });\n\n  ReactDOM.render(\n    <Provider store={store}>\n      <ConnectedRouter\n        matchContext={matchContext}\n        resolver={resolver}\n        initialRenderArgs={initialRenderArgs}\n      />\n    </Provider>,\n    document.getElementById("root"),\n  );\n})();\n'})})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);