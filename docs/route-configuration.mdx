---
name: Route Configuration
menu: Guide
order: 98
---

# Route Configuration

A route object under the default matching algorithm and route element resolver consists of 4 properties, all of which are optional:

- `path`: a string defining the pattern for the route
- `Component` or `getComponent`: the component for the route, or a method that returns the component for the route
- `data` or `getData`: additional data for the route, or a method that returns additional data for the route
- `defer`: whether to wait for all parent `data` or `getData` promises to resolve before getting data for this route and its descendants
- `render`: a method that returns the element for the route
- `children`: an array of child route objects, or an object of those arrays; if using JSX configuration components, this comes from the JSX children

A route configuration consists of an array of route objects. You can generate such an array of route objects from JSX with `<Route>` elements using `makeRouteConfig`.

## path

Specify a `path` pattern to control the paths for which a route is active. These patterns are handled using [Path-to-RegExp](https://github.com/pillarjs/path-to-regexp) and follow the rules there. Both named and unnamed parameters will be captured in `params` and `routeParams` as below. The following are common patterns:

- `/path/subpath`
  - Matches `/path/subpath`
- `/path/:param`
  - Matches `/path/foo` with `params` of `{ param: 'foo' }`
- `/path/:regexParam(\\d+)`
  - Matches `/path/123` with `params` of `{ regexParam: '123' }`
  - Does not match `/path/foo`
- `/path/:optionalParam?`
  - Matches `/path/foo` with `params` of `{ optionalParam: 'foo' }`
  - Matches `/path` with `params` of `{ optionalParam: undefined }`
- `/path/*`
  - Matches `/path/foo/bar`

Routes are matched based on their `path` properties in a depth-first manner, where `path` on the route must match the prefix of the remaining current path. Routing continues through any routes that do not have `path` set. To configure a default or "index" route, use a route with no `path`.

## Component or getComponent

Define the component for a route using either a `Component` field or a `getComponent` method. `Component` should be a component class or function. `getComponent` should be a function that returns a component class or function, or a promise that resolves to either of those. Routes that specify neither will still match if applicable, but will not have a component associated with them.

Given the following route configuration:

```js
const routes = makeRouteConfig(
  <Route path="/" Component={AppPage}>
    <Route Component={MainPage}>
      <Route Component={MainSection} />
      <Route path="other" Component={OtherSection} />
    </Route>
    <Route path="widgets">
      <Route Component={WidgetsPage} />
      <Route path=":widgetId" Component={WidgetPage} />
    </Route>
  </Route>,
);
```

The router will have routes as follows:

- `/`, rendering:

```js
<AppPage>
  <MainPage>
    <MainSection />
  </MainPage>
</AppPage>
```

- `/other`, rendering:

```js
<AppPage>
  <MainPage>
    <OtherSection />
  </MainPage>
</AppPage>
```

- `/widgets`, rendering:

```js
<AppPage>
  <WidgetsPage />
</AppPage>
```

- `/widgets/${widgetId}` (e.g. `/widgets/foo`), rendering:

```js
<AppPage>
  <WidgetPage />
</AppPage>
```

By default, route components receive additional props describing the current routing state. These include:

- `location`: the current [location object](https://github.com/4Catalyzer/farce#locations-and-location-descriptors)
- `params`: the union of path parameters for all matched routes
- `routes`: an array of all matched route objects
- `route`: the route object corresponding to this component
- `routeParams`: the path parameters for `route`
- `match`: an object with `location` and `params` as properties, conforming to the `matchShape` prop type validator
- `router`: an object with static router properties, conforming to the `routerShape` prop type validator
  - `push(location)`: navigates to a new location
  - `replace(location)`: replaces the existing history entry
  - `go(delta)`: moves `delta` steps in the history stack
  - `isActive(match, location, { exact })`: for `match` as above, returns whether `match` corresponds to `location` or a subpath of `location`; if `exact` is set, returns whether `match` corresponds exactly to `location`
  - `matcher`: an object implementing the matching algorithm
    - `format(pattern, params)`: returns the path string for a pattern of the same format as a route `path` and a object of the corresponding path parameters
  - `addTransitionHook(hook)`: adds a [transition hook](https://github.com/4Catalyzer/farce#transition-hooks) that can [block navigation](#blocking-navigation)

The `getComponent` method receives an object containing these properties as its argument.

## data or getData

Specify the `data` property or `getData` method to inject data into a route component as the `data` prop. `data` can be any value. `getData` can be any value, or a promise that resolves to any value. `getData` receives an object containing the routing state, as described above.

The `getData` method is intended for loading additional data from your back end for a given route. By design, all requests for asynchronous component and data dependencies will be issued in parallel. Found uses static route configurations specifically to enable issuing these requests in parallel.

If you need additional context such as a store instance to fetch data, specify this as the `matchContext` prop to your router. This context value will then be available as the `context` property on the argument to `getData`.

```js
const route = {
  path: 'widgets/:widgetId',
  Component: WidgetPage,
  getData: ({ params, context }) => (
    context.store.dispatch(Actions.getWidget(params.widgetId))
  ),
}

// <Router matchContext={{ store }} />
```

It does not make sense to specify `data` or `getData` if the route does not have a component as above or a `render` method as below.

## defer

By default, Found will issue all data fetching operations in parallel. However, if you wish to defer data fetching for a given route until its parent data promises has been resolved, you may do so by setting `defer` on the route.

```js
<Route Component={Parent} getData={getParentData}>
  <Route Component={Child} getData={getChildData} defer />
</Route>
```

Setting `defer` on a route will make the resolver defer calling its `getData` method and the `getData` methods on all of its descendants until all of its parent data promises have resolved.

This should be a relatively rare scenario, as generally user experience is better if all data are fetched in parallel, but in some cases it can be desirable to avoid making data fetching operations that are guaranteed to fail, such as when the user is not authenticated, when optimizing for client bandwidth usage or API utilization.

## render

Specify the `render` method to further customize how the route renders. This method should return a React element to render that element, `undefined` if it has a pending asynchronous component or data dependency and is not ready to render, or `null` to render no component. It receives an object with the following properties:

- `match`: the routing state object, as above
- `Component`: the component for the route, if any; `null` if the component has not yet been loaded
- `props`: the default props for the route component, specifically `match` with `data` as an additional property; `null` if `data` have not yet been loaded
- `data`: the data for the route, as above; `null` if the data have not yet been loaded

Note that, when specifying this `render` method, `Component` or `getComponent` will have no effect other than controlling the value of the `Component` property on the argument to `render`.

You can use this method to render per-route loading state.

```js
function render({ Component, props }) {
  if (!Component || !props) {
    return <LoadingIndicator />;
  }

  return <Component {...props} />;
}
```

If any matched routes have unresolved asynchronous component or data dependencies, the router will initially attempt to render all such routes in their loading state. If those routes all implement `render` methods and return non-`undefined` values from their `render` methods, the router will render the matched routes in their loading states. Otherwise, the router will continue to render the previous set of routes until all asynchronous dependencies resolve.

## Named child routes

Specify an object for the `children` property on a route to set up named child routes. A route with named child routes will match only if every route group matches. The elements corresponding to the child routes will be available on their parent as props with the same name as the route groups.

```js
function AppPage({ nav, main }) {
  return (
    <div className="app">
      <div className="nav">
        {nav}
      </div>
      <div className="main">
        {main}
      </div>
    </div>
  );
}

const route = {
  path: '/',
  Component: AppPage,
  children: [
    {
      path: 'foo',
      children: {
        nav: [
          {
            path: '(.*)?',
            Component: FooNav,
          },
        ],
        main: [
          {
            path: 'a',
            Component: FooA,
          },
          {
            path: 'b',
            Component: FooB,
          },
        ],
      },
    },
    {
      path: 'bar',
      children: {
        nav: [
          {
            path: '(.*)?',
            Component: BarNav,
          },
        ],
        main: [
          {
            Component: BarMain,
          },
        ],
      },
    },
  ],
};

const jsxRoute = (
  <Route path="/" Component={AppPage}>
    <Route path="foo">
      {{
        nav: (
          <Route path="(.*)?" Component={FooNav} />
        ),
        main: [
          <Route path="a" Component={FooA} />,
          <Route path="b" Component={FooB} />,
        ],
      }}
    </Route>
    <Route path="bar">
      {{
        nav: (
          <Route path="(.*)?" Component={BarNav} />
        ),
        main: (
          <Route Component={BarMain} />
        ),
      }}
    </Route>
  </Route>
);
```

## Redirects

The `Redirect` route class sets up static redirect routes. You can also use it to create JSX `<Redirect>` elements for use with `makeRouteConfig`. This class takes `from` and `to` properties. `from` should be a path pattern as for normal routes above. `to` can be either a path pattern or a function. If it is a path pattern, the router will populate path parameters appropriately. If it is a function, it will receive the same routing state object as `getComponent` and `getData`, as described above.

```js
const redirect1 = new Redirect({
  from: 'widget/:widgetId',
  to: '/widgets/:widgetId',
});

const redirect2 = new Redirect({
  from: 'widget/:widgetId',
  to: ({ params }) => `/widgets/${params.widgetId}`,
});

const jsxRedirect1 = (
  <Redirect
    from="widget/:widgetId"
    to="/widgets/:widgetId"
  />
);

const jsxRedirect2 = (
  <Redirect
    from="widget/:widgetId"
    to={({ params }) => `/widgets/${params.widgetId}`}
  />
);
```

If you need more custom control over redirection, throw a `RedirectException` in your route's `render` method with a [location descriptor](https://github.com/4Catalyzer/farce#locations-and-location-descriptors) for the redirect destination.

```js
const customRedirect = {
  getData: fetchRedirectInfo,
  render: ({ data }) => {
    if (data) {
      throw new RedirectException(data.redirectLocation);
    }
  },
}
```

## Error handling

The `HttpError` class signals handled router-level error states. This error class takes a status value that should be an integer corresponding to an HTTP error code and an optional data value of any type. You can handle these errors and render appropriate error feedback in the router-level render method described below.

```js
throw new HttpError(status, data);
```

The router will throw a `new HttpError(404)` in the case when no routes match the current location. Otherwise, you can throw `HttpError` instances in the `getComponent`, `getData`, and `render` methods to signal error states.

```js
const route = {
  path: 'widgets/:widgetId',
  Component: WidgetPage,
  getData: ({ params: { widgetId } }) => (
    fetchWidget(widgetId).catch(() => { throw new HttpError(404); })
  ),
};
```

## Custom route classes

You can implement reusable logic in routes with a custom route class. When extending `Route`, methods defined on the class will be overridden by explicitly specified route properties. You can use custom route classes for either object route configurations or JSX route configurations.

> **Note:** To avoid issues with [React Hot Loader](https://gaearon.github.io/react-hot-loader/), custom route classes should usually extend `Route`.

```js
class AsyncRoute extends Route {
  // An explicit render property on the route will override this.
  render({ Component, props }) {
    return Component && props ? (
      <Component {...props} />
    ) : (
      <LoadingIndicator />
    );
}

const myRoute = new AsyncRoute(properties);
const myJsxRoute = <AsyncRoute {...properties} />;
```
